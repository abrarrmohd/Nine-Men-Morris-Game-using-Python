# -*- coding: utf-8 -*-
"""MiniMaxOpeningImproved.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wtI6qgd5tD73ljU4Juh-_DU0kj7SlbUV
"""

import copy
import sys

class MinimaxOpening():
    positions_evaluated=0
    def __init__(self,board,depth):
        self.board=board
        self.depth=depth

    def generateAdd(self,board):
        gaL=[]
        for i in range(21):
            if board[i]=='x':
                b=board
                b=b[0:i]+'W'+b[i+1:]
                if self.closeMill(i,b):
                    gaL=self.generateRemove(b,gaL)
                else:
                    gaL.append(b)
        return gaL
  
    def generateRemove(self,board,grL):
        flag=0
        for i in range(21):
            if board[i]=='B':
                if not self.closeMill(i,board):
                    flag=1
                    tempb=board
                    tempb=tempb[0:i]+'x'+tempb[i+1:]
                    grL.append(tempb)
        if flag==0:
            grL.append(board)
        return grL

    def closeMill(self,i,b):
        #print('hmm')
        c=b[i]
        #print(c)
        if c=='W' or c=='B':
            if i==0:
                if (b[6]==c and b[18]==c) or (b[2]==c and b[4]==c):
                    return True
                else:
                    return False
            elif i==1:
                if (b[11]==c and b[20]==c):
                    return True
                else:
                    return False
            elif i==2:
                if (b[0]==c and b[4]==c) or (b[7]==c and b[15]==c):
                    return True
                else:
                    return False
            elif i==3:
                if b[10]==c and b[17]==c:
                    return True
                else:
                    return False
            elif i==4:
                if (b[2]==c and b[0]==c) or (b[8]==c and b[12]==c):
                    return True
                else:
                    return False
            elif i==5:
                if b[9]==c and b[14]==c:
                    return True
                else:
                    return False
            elif i==6:
                if (b[7]==c and b[8]==c) or (b[0]==c and b[18]==c):
                    return True
                else:
                    return False
            elif i==7:
                if (b[6]==c and b[8]==c) or (b[2]==c and b[15]==c):
                    return True
                else: 
                    return False
            elif i==8:
                if (b[6]==c and b[7]==c) or (b[4]==c and b[12]==c):
                    return True
                else:
                    return False
            elif i==9:
                if (b[14]==c and b[5]==c) or (b[10]==c and b[11]==c):
                    return True
                else:
                    return False
            elif i==10:
                if (b[3]==c and b[17]==c) or (b[9]==c and b[11]==c):
                    return True
                else:
                    return False
            elif i==11:
                if (b[9]==c and b[10]==c) or (b[1]==c and b[20]==c):
                    return True
                else:
                    return False
            elif i==12:
                if (b[8]==c and b[4]==c) or (b[13]==c and b[14]==c):
                    return True
                else:
                    return False
            elif i==13:
                if (b[14]==c and b[12]==c) or (b[16]==c and b[19]==c):
                    return True
                else:
                    return False
            elif i==14:
                if (b[12]==c and b[13]==c) or (b[9]==c and b[5]==c):
                    return True
                else:
                    return False
            elif i==15:
                if (b[2]==c and b[7]==c) or (b[16]==c and b[17]==c):
                    return True
                else:
                    return False
            elif i==16:
                if (b[15]==c and b[17]==c) or (b[13]==c and b[19]==c):
                    return True
                else:
                    return False
            elif i==17:
                if (b[16]==c and b[15]==c) or (b[10]==c and b[3]==c):
                    return True
                else:
                    return False
            elif i==18:
                if (b[6]==c and b[0]==c) or (b[19]==c and b[20]==c):
                    return True
                else:
                    return False
            elif i==19:
                if (b[16]==c and b[13]==c) or (b[18]==c and b[20]==c):
                    return True
                else:
                    return False
            elif i==20:
                if (b[1]==c and b[11]==c) or (b[18]==c and b[19]==c):
                    return True
                else:
                    return False
            else:
                return False
            
    def generateBlackMoves(self,x):
        tempB=copy.deepcopy(x)
        for i in range(len(tempB)):
            if tempB[i]=='W':
                tempB=tempB[0:i]+'B'+tempB[i+1:]
            elif tempB[i]=='B':
                tempB=tempB[0:i]+'W'+tempB[i+1:]
        tempchild = self.generateAdd(tempB)
        tempc=[]
        for y in tempchild:
            for z in range(len(y)):
                if y[z]=='W':
                    y=y[0:z]+'B'+y[z+1:]
                elif y[z]=='B':
                    y=y[0:z]+'W'+y[z+1:]
            tempc.append(y)
        return tempc

    def neighbours(self,j,board):
        if j==0:
            return [1,2,6]
        elif j==1:
            return [0,11]
        elif j==2:
            return [0,3,4,7]
        elif j==3:
            return [2,10]
        elif j==4:
            return [2,5,8]
        elif j==5:
            return [4,9]
        elif j==6:
            return [0,7,18]
        elif j==7:
            return [2,6,8,15]
        elif j==8:
            return [4,7,12]
        elif j==9:
            return [5,10,14]
        elif j==10:
            return [3,9,11,17]
        elif j==11:
            return [1,10,20]
        elif j==12:
            return [8,13]
        elif j==13:
            return [12,14,16]
        elif j==14:
            return [9,13]
        elif j==15:
            return [7,16]
        elif j==16:
            return [13,15,17,19]
        elif j==17:
            return [10,16]
        elif j==18:
            return [6,19]
        elif j==19:
            return [16,18,20]
        elif j==20:
            return [11,19]

    def num_closemill(self,b,c):
        count=0
        if (b[0]==c and b[6]==c and b[18]==c):
            count=count+1
        if (b[0]==c and b[2]==c and b[4]==c):
            count=count+1
        if (b[1]==c and b[11]==c and b[20]==c):
            count=count+1
        if (b[2]==c and b[7]==c and b[15]==c):
            count=count+1
        if (b[3]==c and b[10]==c and b[17]==c):
            count=count+1
        if (b[4]==c and b[8]==c and b[12]==c):
            count=count+1
        if (b[5]==c and b[9]==c and b[14]==c):
            count=count+1
        if (b[6]==c and b[7]==c and b[8]==c):
            count=count+1
        if (b[9]==c and b[10]==c and b[11]==c):
            count=count+1
        if (b[12]==c and b[13]==c and b[14]==c):
            count=count+1
        if (b[13]==c and b[16]==c and b[19]==c):
            count=count+1
        if (b[15]==c and b[16]==c and b[17]==c):
            count=count+1
        if (b[18]==c and b[19]==c and b[20]==c):
            count=count+1
        return count
  
    def mobility(self,x,c):
        score=0
        for i in range(len(x)):
            if x[i]==c:
                n=self.neighbours(i,x)
                for j in n:
                    if x[j]==c:
                        score=score+5
                    else:
                        score=score-1
        return score

    def swap(self,x):
        tempB=copy.deepcopy(x)
        for i in range(len(tempB)):
            if tempB[i]=='W':
                tempB=tempB[0:i]+'B'+tempB[i+1:]
            elif tempB[i]=='B':
                tempB=tempB[0:i]+'W'+tempB[i+1:]
        return tempB
  
    def StaticEstimation(self,x):
        black=0
        white=0
        whitemills=0
        blackmills=0
        whitemills=self.num_closemill(x,'W')
        blackmills=self.num_closemill(x,'B')

        mob_score_W=self.mobility(x,'W')
        mob_score_B=self.mobility(x,'B')

        for i in x:
            if i=='W':
                white=white+1
            elif i=='B':
                black= black+1
        return 4*(white-black)+3*(whitemills)-blackmills+2*((mob_score_W/white)-(mob_score_B/black))

    def maxmin(self,x,depth):
        maxboardchoice=[]
        if depth==0:
            self.positions_evaluated=self.positions_evaluated+1
            return self.StaticEstimation(x),x
        else:
            v=float('-inf')
            children=self.generateAdd(x)
            for y in children:
                v1,_=self.minmax(y,depth-1)
                if v<v1:
                    v=v1
                    maxboardchoice=y
        return v,maxboardchoice

    def minmax(self,x,depth):
        minboardchoice=[]
        if depth==0:
            self.positions_evaluated=self.positions_evaluated+1
            return self.StaticEstimation(x),x
        else:
            v=float('inf')
            children= self.generateBlackMoves(x)
            for y in children:
                v2,_=self.maxmin(y,depth-1)
                if v>v2:
                    v=v2
                    minboardchoice=y
        return v,minboardchoice


def print_board(board):
    print(board[18],'______________',board[19],'_____________',board[20])
    print('|                |               |')
    print('|     ',board[15],'_______',board[16],'_______',board[17],'    |')
    print('|      |         |         |     |')
    print('|      |  ',board[12],'___',board[13],'___',board[14],'  |     |')
    print('|      |   |           |   |     |')
    print(board[6],'____',board[7],'_',board[8],'         ',board[9],'_',board[10],'___',board[11])
    print('|      |   |           |   |     |')
    print('|      |  ',board[4],'_________',board[5],'  |     |')
    print('|      |_/                 |     |')
    print('|     ',board[2],'_________________',board[3],'    |')
    print('|   _/                           |')
    print(board[0],'_/____________________________',board[1])

if __name__=='__main__':
    board_file = sys.argv[1]
    board_output = sys.argv[2]
    depth = int(sys.argv[3])
    with open(board_file, 'r') as f:
        board = f.readline()
    d=MinimaxOpening(board,depth)
    l=(d.maxmin(board,depth))
    print('Input position: ',board)
    print_board(board)
    print('************************************************************************')
    print('Output position: ',l[1])
    print_board(l[1])
    print('Positions evaluated by static estimation: ',d.positions_evaluated)
    print('MINIMAX ESTIMATE: ',l[0])
    print('Depth: ',depth)
    with open(board_output,'w') as f:
        f.write(''.join(l[1]))

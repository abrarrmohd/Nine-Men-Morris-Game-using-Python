# -*- coding: utf-8 -*-
"""MiniMaxGameBlack.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WuaQDgJXip_JcpkbO1_dSeuV_uzQIvg9
"""

import copy
import sys
class miniGameBlack:

    positions_evaluated=0
    def __init__(self,board,depth):
        self.board=board
        self.depth=depth
    
    def GenerateMovesMidgameEndgame(self,board):
        white=0
        for i in range(len(board)):
            if board[i]=='W':
                white=white+1
        if white==3:
            return self.GenerateHopping(board)
        else:
            return self.GenerateMove(board)

    def GenerateMove(self,board):
        gM=[]
        for j in range(len(board)):
            if board[j]=='W':
                n=self.neighbours(j,board)
                for i in n:
                    if board[i] =='x':
                        b=copy.deepcopy(board)
                        b=b[0:j]+'x'+b[j+1:]
                        b=b[0:i]+'W'+b[i+1:]
                        if self.closeMill(i,b):
                            gM=self.generateRemove(b,gM)
                        else:
                            gM.append(b)
        return gM
        
    def GenerateHopping(self,board):
        GH=[]
        for i in range(len(board)):
            if board[i]=='W':
                for j in range(len(board)):
                    if board[j]=='x':
                        b=copy.deepcopy(board)
                        b=b[0:j]+'W'+b[j+1:]
                        b=b[0:i]+'x'+b[i+1:]
                        if self.closeMill(j,b):
                            GH=self.generateRemove(b,GH)
                        else:
                            GH.append(b)
        return GH

    def generateRemove(self,board,grL):
        flag=0
        for i in range(len(board)):
            if board[i]=='B':
                if not self.closeMill(i,board):
                    flag=1
                    tempb=copy.deepcopy(board)
                    tempb=tempb[0:i]+'x'+tempb[i+1:]
                    grL.append(tempb)
        if flag==0:
            grL.append(board)
        return grL

    def neighbours(self,j,board):
        if j==0:
            return [1,2,6]
        elif j==1:
            return [0,11]
        elif j==2:
            return [0,3,4,7]
        elif j==3:
            return [2,10]
        elif j==4:
            return [2,5,8]
        elif j==5:
            return [4,9]
        elif j==6:
            return [0,7,18]
        elif j==7:
            return [2,6,8,15]
        elif j==8:
            return [4,7,12]
        elif j==9:
            return [5,10,14]
        elif j==10:
            return [3,9,11,17]
        elif j==11:
            return [1,10,20]
        elif j==12:
            return [8,13]
        elif j==13:
            return [12,14,16]
        elif j==14:
            return [9,13]
        elif j==15:
            return [7,16]
        elif j==16:
            return [13,15,17,19]
        elif j==17:
            return [10,16]
        elif j==18:
            return [6,19]
        elif j==19:
            return [16,18,20]
        elif j==20:
            return [11,19]


    def closeMill(self,i,b):
        c=b[i]
        if c=='W' or c=='B':
            if i==0:
                if (b[6]==c and b[18]==c) or (b[2]==c and b[4]==c):
                    return True
                else:
                    return False
            elif i==1:
                if (b[11]==c and b[20]==c):
                    return True
                else:
                    return False
            elif i==2:
                if (b[0]==c and b[4]==c) or (b[7]==c and b[15]==c):
                    return True
                else:
                    return False
            elif i==3:
                if b[10]==c and b[17]==c:
                    return True
                else:
                    return False
            elif i==4:
                if (b[2]==c and b[0]==c) or (b[8]==c and b[12]==c):
                    return True
                else:
                    return False
            elif i==5:
                if b[9]==c and b[14]==c:
                    return True
                else:
                    return False
            elif i==6:
                if (b[7]==c and b[8]==c) or (b[0]==c and b[18]==c):
                    return True
                else:
                    return False
            elif i==7:
                if (b[6]==c and b[8]==c) or (b[2]==c and b[15]==c):
                    return True
                else: 
                    return False
            elif i==8:
                if (b[6]==c and b[7]==c) or (b[4]==c and b[12]==c):
                    return True
                else:
                    return False
            elif i==9:
                if (b[14]==c and b[5]==c) or (b[10]==c and b[11]==c):
                    return True
                else:
                    return False
            elif i==10:
                if (b[3]==c and b[17]==c) or (b[9]==c and b[11]==c):
                    return True
                else:
                    return False
            elif i==11:
                if (b[9]==c and b[10]==c) or (b[1]==c and b[20]==c):
                    return True
                else:
                    return False
            elif i==12:
                if (b[8]==c and b[4]==c) or (b[13]==c and b[14]==c):
                    return True
                else:
                    return False
            elif i==13:
                if (b[14]==c and b[12]==c) or (b[16]==c and b[19]==c):
                    return True
                else:
                    return False
            elif i==14:
                if (b[12]==c and b[13]==c) or (b[9]==c and b[5]==c):
                    return True
                else:
                    return False
            elif i==15:
                if (b[2]==c and b[7]==c) or (b[16]==c and b[17]==c):
                    return True
                else:
                    return False
            elif i==16:
                if (b[15]==c and b[17]==c) or (b[13]==c and b[19]==c):
                    return True
                else:
                    return False
            elif i==17:
                if (b[16]==c and b[15]==c) or (b[10]==c and b[3]==c):
                    return True
                else:
                    return False
            elif i==18:
                if (b[6]==c and b[0]==c) or (b[19]==c and b[20]==c):
                    return True
                else:
                    return False
            elif i==19:
                if (b[16]==c and b[13]==c) or (b[18]==c and b[20]==c):
                    return True
                else:
                    return False
            elif i==20:
                if (b[1]==c and b[11]==c) or (b[18]==c and b[19]==c):
                    return True
                else:
                    return False
            else:
                return False
            
    def generateBlackMoves(self,x):
        tempB=copy.deepcopy(x)
        for i in range(len(tempB)):
            if tempB[i]=='W':
                tempB=tempB[0:i]+'B'+tempB[i+1:]
            elif tempB[i]=='B':
                tempB=tempB[0:i]+'W'+tempB[i+1:]
        tempchild = self.GenerateMovesMidgameEndgame(tempB)
        tempc=[]
        for y in tempchild:
            for z in range(len(y)):
                if y[z]=='W':
                    y=y[0:z]+'B'+y[z+1:]
                elif y[z]=='B':
                    y=y[0:z]+'W'+y[z+1:]
            tempc.append(y)
        return tempc

    def StaticEstimation(self,x):
        blackmoves=len(self.generateBlackMoves(x))
        Black=0
        White=0
        for i in x:
            if i=='W':
                White=White+1
            elif i=='B':
                Black= Black+1
        if Black<=2:
            return 10**20                  
        elif White<=2:
            return -10**20                  
        elif blackmoves==0:
            return 10**20       
        else:
            return ( (1000*(White-Black))-blackmoves)

    def swap(self,x):
        tempB=copy.deepcopy(x)
        for i in range(len(tempB)):
            if tempB[i]=='W':
                tempB=tempB[0:i]+'B'+tempB[i+1:]
            elif tempB[i]=='B':
                tempB=tempB[0:i]+'W'+tempB[i+1:]
        return tempB

    def maxmin(self,x,depth):
        if depth==0:
            self.positions_evaluated=self.positions_evaluated+1
            return self.StaticEstimation(x),x
        else:
            maxboardchoice=[]
            v=-10**20-2 
            children=self.GenerateMovesMidgameEndgame(x)
            for y in children:
                v1,_=self.minmax(y,depth-1)
                if v<v1:
                    v=v1
                    maxboardchoice=y
            return v,maxboardchoice

    def minmax(self,x,depth):
        if depth==0:
            self.positions_evaluated=self.positions_evaluated+1
            return self.StaticEstimation(x),x
        else:
            minboardchoice=[]
            v=10**20    
            children= self.generateBlackMoves(x)
            for y in children:
                v2,_=self.maxmin(y,depth-1)
                if v>v2:
                    v=v2
                    minboardchoice=y
            return v,minboardchoice
def print_board(board):
    print(board[18],'______________',board[19],'_____________',board[20])
    print('|                |               |')
    print('|     ',board[15],'_______',board[16],'_______',board[17],'    |')
    print('|      |         |         |     |')
    print('|      |  ',board[12],'___',board[13],'___',board[14],'  |     |')
    print('|      |   |           |   |     |')
    print(board[6],'____',board[7],'_',board[8],'         ',board[9],'_',board[10],'___',board[11])
    print('|      |   |           |   |     |')
    print('|      |  ',board[4],'_________',board[5],'  |     |')
    print('|      |_/                 |     |')
    print('|     ',board[2],'_________________',board[3],'    |')
    print('|   _/                           |')
    print(board[0],'_/____________________________',board[1])

if __name__=='__main__':
    board_file = sys.argv[1]
    board_output = sys.argv[2]
    depth = int(sys.argv[3])
    with open(board_file, 'r') as f:
        board = f.readline()
    d=miniGameBlack(board,depth)
    l=(d.maxmin(d.swap(board),depth))
    print('Input position: ',board)
    print_board(board)
    print('************************************************************************')
    print('Output position: ',d.swap(l[1]))
    print_board(d.swap(l[1]))
    print('Positions evaluated by static estimation: ',d.positions_evaluated)
    print('MINIMAX ESTIMATE: ',l[0])
    print('Depth: ',depth)
    with open(board_output,'w') as f:
        f.write(''.join(l[1]))

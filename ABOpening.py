# -*- coding: utf-8 -*-
"""ABOpening.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pGiPH6D-LuifZTx45nlFVxt9YHYMHJJC
"""

import copy
import sys
class MinimaxOpening():
    positions_evaluated=0
    def __init__(self,board,depth):
        self.board=board
        self.depth=depth

    def generateAdd(self,board):
        gaL=[]
        for i in range(21):
            if board[i]=='x':
                b=copy.copy(board)
                b=b[0:i]+'W'+b[i+1:]
                if self.closeMill(i,b):
                    gaL=self.generateRemove(b,gaL)
                else:
                    gaL.append(b)
        return gaL
  
    def generateRemove(self,board,grL):
        flag=0
        for i in range(21):
            if board[i]=='B':
                if not self.closeMill(i,board):
                    flag=1
                    tempb=copy.copy(board)
                    tempb=tempb[0:i]+'x'+tempb[i+1:]
                    grL.append(tempb)
        if flag==0:
            grL.append(board)
        return grL

    def closeMill(self,i,b):
        c=b[i]
        if c=='W' or c=='B':
            if i==0:
                if (b[6]==c and b[18]==c) or (b[2]==c and b[4]==c):
                    return True
                else:
                    return False
            elif i==1:
                if (b[11]==c and b[20]==c):
                    return True
                else:
                    return False
            elif i==2:
                if (b[0]==c and b[4]==c) or (b[7]==c and b[15]==c):
                    return True
                else:
                    return False
            elif i==3:
                if b[10]==c and b[17]==c:
                    return True
                else:
                    return False
            elif i==4:
                if (b[2]==c and b[0]==c) or (b[8]==c and b[12]==c):
                    return True
                else:
                    return False
            elif i==5:
                if b[9]==c and b[14]==c:
                    return True
                else:
                    return False
            elif i==6:
                if (b[7]==c and b[8]==c) or (b[0]==c and b[18]==c):
                    return True
                else:
                    return False
            elif i==7:
                if (b[6]==c and b[8]==c) or (b[2]==c and b[15]==c):
                    return True
                else: 
                    return False
            elif i==8:
                if (b[6]==c and b[7]==c) or (b[4]==c and b[12]==c):
                    return True
                else:
                    return False
            elif i==9:
                if (b[14]==c and b[5]==c) or (b[10]==c and b[11]==c):
                    return True
                else:
                    return False
            elif i==10:
                if (b[3]==c and b[17]==c) or (b[9]==c and b[11]==c):
                    return True
                else:
                    return False
            elif i==11:
                if (b[9]==c and b[10]==c) or (b[1]==c and b[20]==c):
                    return True
                else:
                    return False
            elif i==12:
                if (b[8]==c and b[4]==c) or (b[13]==c and b[14]==c):
                    return True
                else:
                    return False
            elif i==13:
                if (b[14]==c and b[12]==c) or (b[16]==c and b[19]==c):
                    return True
                else:
                    return False
            elif i==14:
                if (b[12]==c and b[13]==c) or (b[9]==c and b[5]==c):
                    return True
                else:
                    return False
            elif i==15:
                if (b[2]==c and b[7]==c) or (b[16]==c and b[17]==c):
                    return True
                else:
                    return False
            elif i==16:
                if (b[15]==c and b[17]==c) or (b[13]==c and b[19]==c):
                    return True
                else:
                    return False
            elif i==17:
                if (b[16]==c and b[15]==c) or (b[10]==c and b[3]==c):
                    return True
                else:
                    return False
            elif i==18:
                if (b[6]==c and b[0]==c) or (b[19]==c and b[20]==c):
                    return True
                else:
                    return False
            elif i==19:
                if (b[16]==c and b[13]==c) or (b[18]==c and b[20]==c):
                    return True
                else:
                    return False
            elif i==20:
                if (b[1]==c and b[11]==c) or (b[18]==c and b[19]==c):
                    return True
                else:
                    return False
            else:
                return False
            
    def generateBlackMoves(self,x):
        tempB=copy.deepcopy(x)
        for i in range(len(tempB)):
            if tempB[i]=='W':
                tempB=tempB[0:i]+'B'+tempB[i+1:]
            elif tempB[i]=='B':
                tempB=tempB[0:i]+'W'+tempB[i+1:]
        tempchild = self.generateAdd(tempB)
        tempc=[]
        for y in tempchild:
            for z in range(len(y)):
                if y[z]=='W':
                    y=y[0:z]+'B'+y[z+1:]
                elif y[z]=='B':
                    y=y[0:z]+'W'+y[z+1:]
            tempc.append(y)
        return tempc
    
    def StaticEstimation(self,x):
        black=0
        white=0
        for i in x:
            if i=='W':
                white=white+1
            elif i=='B':
                black= black+1
        return white-black
    
    def maxmin(self,x,depth,alpha,beta):
        if depth==0:
            self.positions_evaluated=self.positions_evaluated+1
            return self.StaticEstimation(x),x
        else:
            maxboardchoice=[]
            v=(-10**20)-2  #float('-inf')
            children=self.generateAdd(x)
            for y in children:
                v1,_=self.minmax(y,depth-1,alpha,beta)
                if v<v1:
                    v=v1
                    maxboardchoice=y
                if v>=beta:
                    return v,maxboardchoice
                else:
                    alpha=max(v,alpha)
            return v,maxboardchoice

    def minmax(self,x,depth,alpha,beta):
        if depth==0:
            self.positions_evaluated=self.positions_evaluated+1
            return self.StaticEstimation(x),x
        else:
            minboardchoice=[]
            v=(10**20)+2 #float('inf')
            children= self.generateBlackMoves(x)
            for y in children:
                v2,_=self.maxmin(y,depth-1,alpha,beta)
                if v>v2:
                    v=v2
                    minboardchoice=y
                if v<=alpha:
                    return v,minboardchoice
                else:
                    beta=min(v,beta)
            return v,minboardchoice
    
def print_board(board):
    print(board[18],'______________',board[19],'_____________',board[20])
    print('|                |               |')
    print('|     ',board[15],'_______',board[16],'_______',board[17],'    |')
    print('|      |         |         |     |')
    print('|      |  ',board[12],'___',board[13],'___',board[14],'  |     |')
    print('|      |   |           |   |     |')
    print(board[6],'____',board[7],'_',board[8],'         ',board[9],'_',board[10],'___',board[11])
    print('|      |   |           |   |     |')
    print('|      |  ',board[4],'_________',board[5],'  |     |')
    print('|      |_/                 |     |')
    print('|     ',board[2],'_________________',board[3],'    |')
    print('|   _/                           |')
    print(board[0],'_/____________________________',board[1])

if __name__=='__main__':
    board_file = sys.argv[1]
    board_output = sys.argv[2]
    depth = int(sys.argv[3])
    with open(board_file, 'r') as f:
        board = f.readline()
    d=MinimaxOpening(board,depth)
    l=(d.maxmin(board,depth,-10**20 ,10**20 ))
    print('Input position: ',board)
    print_board(board)
    print('************************************************************************')
    print('Output position: ',l[1])
    print_board(l[1])
    print('Positions evaluated by static estimation: ',d.positions_evaluated)
    print('MINIMAX ESTIMATE: ',l[0])
    print('Depth: ',depth)
    with open(board_output,'w') as f:
        f.write(''.join(l[1]))

